// Generated by CoffeeScript 1.3.3
var Core, Table, Tablestakes;

Tablestakes = window.Tablestakes || {};

window.Tablestakes = Tablestakes;

Tablestakes.Table = Table = (function() {

  function Table() {}

  Table.prototype.attributes = {};

  Table.prototype.margin = {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };

  Table.prototype.width = 960;

  Table.prototype.height = 500;

  Table.prototype.id = Math.floor(Math.random() * 10000);

  Table.prototype.header = true;

  Table.prototype.noData = "No Data Available.";

  Table.prototype.childIndent = 20;

  Table.prototype.columns = {
    key: "key",
    label: "Name",
    type: "text"
  };

  Table.prototype.tableClassName = "class";

  Table.prototype.iconOpenImg = "css/img/expand.gif";

  Table.prototype.iconCloseImg = "css/img/collapse.gif";

  Table.prototype.dispatch = d3.dispatch("elementClick", "elementDblclick", "elementMouseover", "elementMouseout");

  Table.prototype.columnResize = true;

  Table.prototype.isSortable = true;

  Table.prototype.isEditable = true;

  Table.prototype.gridData = [];

  Table.prototype.tableObject = null;

  Table.prototype.minWidth = 50;

  Table.prototype.tableWidth = 0;

  Table.prototype.isInRender = false;

  Table.prototype.render = function(selector) {
    var setID,
      _this = this;
    this.gridData = [
      {
        values: this.get('data')
      }
    ];
    this.get('columns').forEach(function(column, i) {
      return _this.gridData[0][column['key']] = column['key'];
    });
    setID = function(node, prefix) {
      node['_id'] = prefix;
      if (node.values) {
        node.values.forEach(function(subnode, i) {
          return setID(subnode, prefix + "_" + i);
        });
      }
      if (node._values) {
        return node._values.forEach(function(subnode, i) {
          return setID(subnode, prefix + "_" + i);
        });
      }
    };
    setID(this.gridData[0], "0");
    d3.select(selector).datum(this.gridData).call(function(selection) {
      return _this.update(selection);
    });
    return this;
  };

  Table.prototype.update = function(selection) {
    var _this = this;
    selection.each(function(data) {
      return new Tablestakes.Core({
        data: data,
        selection: selection,
        table: _this
      });
    });
    this.isInRender = false;
    return this;
  };

  Table.prototype.calculateTableWidth = function() {
    var tableWidth;
    tableWidth = 0;
    this.get('columns').forEach(function(column, index) {
      return tableWidth += parseInt(column.width);
    });
    return this.tableWidth = tableWidth;
  };

  Table.prototype.set = function(key, value, options) {
    if ((key != null) && (value != null)) {
      this.attributes[key] = value;
    }
    return this;
  };

  Table.prototype.get = function(key) {
    return this.attributes[key];
  };

  Table.prototype.setMargin = function(margin) {
    if (margin == null) {
      return this.margin;
    }
    this.margin.top = (typeof margin.top !== "undefined" ? margin.top : this.margin.top);
    this.margin.right = (typeof margin.right !== "undefined" ? margin.right : this.margin.right);
    this.margin.bottom = (typeof margin.bottom !== "undefined" ? margin.bottom : this.margin.bottom);
    return this.margin.left = (typeof margin.left !== "undefined" ? margin.left : this.margin.left);
  };

  Table.prototype.Sortable = function(_) {
    if ((_ != null)) {
      this.isSortable = _;
      return this;
    } else {
      return this.isSortable;
    }
  };

  return Table;

})();

Tablestakes.Core = Core = (function() {

  function Core(options) {
    this.table = options.table;
    this.selection = options.selection;
    this.data = options.data;
    this.columns = this.table.get('columns');
    this.render();
  }

  Core.prototype.getCurrentColumnIndex = function(id) {
    var col, currentindex, i, _i, _len, _ref;
    console.log('core getCurrentColumnIndex, id:', id);
    currentindex = this.columns.length;
    _ref = this.columns;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      col = _ref[i];
      if (col.key === id) {
        currentindex = i;
        break;
      }
    }
    return currentindex;
  };

  Core.prototype.findNextNode = function(d) {
    var i, idPath, leaf, nextNodeID, root, _i, _j, _len, _ref, _ref1;
    console.log('core findNextNode');
    nextNodeID = null;
    _ref = this.nodes;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      leaf = _ref[i];
      if (leaf._id === d._id) {
        if (this.nodes.length !== i + 1) {
          nextNodeID = this.nodes[i + 1]._id;
        }
        break;
      }
    }
    if (nextNodeID === null) {
      return null;
    }
    idPath = nextNodeID.split("_");
    root = this.data[0];
    for (i = _j = 1, _ref1 = idPath.length - 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
      root = root.values[parseInt(idPath[i])];
    }
    return root;
  };

  Core.prototype.findPrevNode = function(d) {
    var i, idPath, leaf, prevNodeID, root, _i, _j, _len, _ref, _ref1;
    console.log('core findPrevNode');
    prevNodeID = null;
    _ref = this.nodes;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      leaf = _ref[i];
      if (leaf._id === d._id) {
        break;
      }
      prevNodeID = leaf._id;
    }
    if (prevNodeID === null || prevNodeID === "0") {
      return null;
    }
    idPath = prevNodeID.split("_");
    root = this.data[0];
    for (i = _j = 1, _ref1 = idPath.length - 1; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
      root = root.values[parseInt(idPath[i])];
    }
    return root;
  };

  Core.prototype.keydown = function(node, d) {
    switch (d3.event.keyCode) {
      case 9:
        return this.key_tab(node, d);
      case 38:
        return this.key_up(node, d);
      case 40:
        return this.key_down(node, d);
    }
  };

  Core.prototype.key_tab = function(node, d) {
    var currentindex, nextNode, prevNode;
    d3.event.preventDefault();
    d3.event.stopPropagation();
    currentindex = this.getCurrentColumnIndex(d.activatedID);
    if (d3.event.shiftKey === false) {
      if (currentindex < this.columns.length - 1) {
        d.activatedID = this.columns[currentindex + 1].key;
      } else {
        nextNode = this.findNextNode(d, this.nodes);
        if (nextNode !== null) {
          nextNode.activatedID = this.columns[0].key;
          d.activatedID = null;
        }
      }
    } else {
      if (currentindex > 0) {
        d.activatedID = this.columns[currentindex - 1].key;
      } else {
        prevNode = this.findPrevNode(d, this.nodes);
        if (prevNode !== null) {
          prevNode.activatedID = this.columns[this.columns.length - 1].key;
          d.activatedID = null;
        }
      }
    }
    return this.update();
  };

  Core.prototype.key_down = function(node, d) {
    var currentindex, nextNode;
    nextNode = this.findNextNode(d);
    currentindex = this.getCurrentColumnIndex(d.activatedID);
    if (nextNode !== null) {
      nextNode.activatedID = this.columns[currentindex].key;
      d.activatedID = null;
    }
    return this.update();
  };

  Core.prototype.key_up = function(node, d) {
    var currentindex, prevNode;
    prevNode = this.findPrevNode(d, this.nodes);
    currentindex = this.getCurrentColumnIndex(d.activatedID);
    if (prevNode !== null) {
      prevNode.activatedID = this.columns[currentindex].key;
      d.activatedID = null;
    }
    return this.update();
  };

  Core.prototype.keyup = function(node, d) {
    switch (d3.event.keyCode) {
      case 13:
        d.activatedID = null;
        this.update();
        break;
      case 27:
        d3.select(node).node().value = d[d.activatedID];
        d.activatedID = null;
        this.update();
    }
  };

  Core.prototype.blur = function(d, column) {
    d[column.key] = d3.select('input').node().value;
    if (this.table.isInRender === false) {
      d.activatedID = null;
      return this.update();
    }
  };

  Core.prototype.click = function(d, _, unshift) {
    var _this = this;
    console.log('core click');
    d.activatedID = null;
    d3.event.stopPropagation();
    if (d3.event.shiftKey && !unshift) {
      d.values && d.values.forEach(function(node) {
        if (node.values || node._values) {
          return _this.click(node, 0, true);
        }
      });
      return true;
    }
    if (d.values) {
      d._values = d.values;
      d.values = null;
    } else {
      d.values = d._values;
      d._values = null;
    }
    return this.update();
  };

  Core.prototype.drag = function() {
    var _this = this;
    return d3.behavior.drag().on("drag", function(d, i) {
      var column_newX, column_x, index, table_newX, table_x, th;
      th = d3.select(_this.table).node().parentNode;
      column_x = parseFloat(d3.select(th).attr("width"));
      column_newX = d3.event.x;
      if (_this.table.minWidth < column_newX) {
        d3.select(th).attr("width", column_newX + "px");
        index = parseInt(d3.select(th).attr("ref"));
        _this.columns[index].width = column_newX + "px";
        table_x = parseFloat(_this.tableObject.attr("width"));
        table_newX = table_x + (column_newX - column_x);
        return _this.tableObject.attr("width", table_newX + "px");
      }
    });
  };

  Core.prototype.deactivateAll = function(d) {
    var _this = this;
    d.activatedID = null;
    if (d.values) {
      d.values.forEach(function(item, index) {
        return _this.deactivateAll(item);
      });
    }
    if (d._values) {
      d._values.forEach(function(item, index) {
        return _this.deactivateAll(item);
      });
    }
  };

  Core.prototype.editable = function(node, d, _, unshift) {
    console.log('core editable');
    this.deactivateAll(this.data[0]);
    d.activatedID = d3.select(d3.select(node).node().parentNode).attr("meta-key");
    return this.update();
  };

  Core.prototype.icon = function(d) {
    if (d._values && d._values.length) {
      return this.table.iconOpenImg;
    } else {
      if (d.values && d.values.length) {
        return this.table.iconCloseImg;
      } else {
        return "";
      }
    }
  };

  Core.prototype.folded = function(d) {
    return d._values && d._values.length;
  };

  Core.prototype.hasChildren = function(d) {
    var values;
    values = d.values || d._values;
    return values && values.length;
  };

  Core.prototype.update = function() {
    var _this = this;
    this.table.isInRender = true;
    return this.selection.transition().call(function(selection) {
      return _this.table.update(selection);
    });
  };

  Core.prototype.render = function() {
    var depth, i, node, tableEnter, tbody, thead, theadRow, wrap, wrapEnter,
      _this = this;
    if (!this.data[0]) {
      this.data[0] = {
        key: this.table.noData
      };
    }
    this.tree = d3.layout.tree().children(function(d) {
      return d.values;
    });
    this.nodes = this.tree.nodes(this.data[0]);
    wrap = d3.select('#example_view').selectAll("div").data([[this.nodes]]);
    wrapEnter = wrap.enter().append("div").attr("class", "nvd3 nv-wrap nv-indentedtree");
    tableEnter = wrapEnter.append("table");
    this.table.calculateTableWidth();
    this.tableObject = wrap.select("table").attr("class", this.table.tableClassName).attr("style", "table-layout:fixed;").attr("width", this.table.tableWidth + "px");
    if (this.table.header) {
      thead = tableEnter.append("thead");
      theadRow = thead.append("tr");
      this.columns.forEach(function(column, i) {
        var th;
        th = theadRow.append("th").attr("width", (column.width ? column.width : "100px")).attr("ref", i).style("text-align", (column.type === "numeric" ? "right" : "left"));
        th.append("span").text(column.label);
        if (_this.table.columnResize) {
          th.style("position", "relative");
          th.append("div").attr("class", "table-resizable-handle").call(_this.drag);
          return th.append("br");
        }
      });
    }
    tbody = this.tableObject.selectAll("tbody").data(function(d) {
      return d;
    });
    tbody.enter().append("tbody");
    depth = d3.max(this.nodes, function(node) {
      return node.depth;
    });
    this.tree.size([this.table.height, depth * this.table.childIndent]);
    i = 0;
    node = tbody.selectAll("tr").data(function(d) {
      return d;
    }, function(d) {
      return d.id || (d.id === ++i);
    });
    node.exit().remove();
    node.select("img.nv-treeicon").attr("src", function(d) {
      return _this.icon(d);
    }).classed("folded", this.folded);
    this.nodeEnter = node.enter().append("tr");
    if (this.nodeEnter[0][0]) {
      d3.select(this.nodeEnter[0][0]).style("display", "none");
    }
    return this.columns.forEach(function(column, index) {
      return _this.renderColumn(column, index);
    });
  };

  Core.prototype.renderColumn = function(column, index) {
    var nodeName, self,
      _this = this;
    nodeName = this.nodeEnter.append("td").attr("meta-key", column.key).style("padding-left", function(d) {
      return (index ? 0 : (d.depth - 1) * _this.table.childIndent + (_this.icon(d) ? 0 : 16)) + "px";
    }, "important").style("text-align", (column.type === "numeric" ? "right" : "left")).attr("ref", column.key);
    if (index === 0) {
      nodeName.append("img").classed("nv-treeicon", true).classed("nv-folded", this.folded).attr("src", function(d) {
        return _this.icon(d);
      }).style("width", "14px").style("height", "14px").style("padding", "0 1px").style("display", function(d) {
        if (_this.icon(d)) {
          return "inline-block";
        } else {
          return "none";
        }
      }).on("click", function(a, b, c) {
        return _this.click(a, b, c);
      });
    }
    self = this;
    return nodeName.each(function(td) {
      return self.renderNode(this, column, td, nodeName);
    });
  };

  Core.prototype.renderNode = function(node, column, td, nodeName) {
    var self,
      _this = this;
    self = this;
    if (td.activatedID === column.key) {
      d3.select(node).append("span").attr("class", d3.functor(column.classes)).append("input").attr('type', 'text').attr('value', function(d) {
        return d[column.key] || "";
      }).on("keydown", function(d) {
        return self.keydown(this, d);
      }).on("keyup", function(a, b, c) {
        return self.keyup(this, a, b, c);
      }).on("blur", function(d) {
        return self.blur(d, column);
      }).node().focus();
    } else {
      d3.select(node).append("span").attr("class", d3.functor(column.classes)).text(function(d) {
        if (column.format) {
          return column.format(d);
        } else {
          return d[column.key] || "-";
        }
      });
    }
    if (column.showCount) {
      nodeName.append("span").attr("class", "nv-childrenCount").text(function(d) {
        if ((d.values && d.values.length) || (d._values && d._values.length)) {
          return "(" + ((d.values && d.values.length) || (d._values && d._values.length)) + ")";
        } else {
          return "";
        }
      });
    }
    return nodeName.select("span").on("click", function(a, b, c) {
      if (self.table.isEditable) {
        return self.editable(this, a, b, c);
      }
    });
  };

  return Core;

})();
